# 프론트엔드 CI/CD + deployment 워크플로우
# main 브랜치에 직접 push되거나 PR이 merge되는 경우에 실행되어 빌드, 테스트 후 artifacts를 생성합니다.
# Discord 알림: Repository Secret에 DISCORD_WEBHOOK_URL 설정 시 성공/실패 알림 전송 (docs/DISCORD_NOTIFICATION.md 참고)
name: Frontend CI/CD

on:
  push:               # main 또는 dev 브랜치에 직접 push될 때 실행
    branches:
      - main
      - dev      
  pull_request:       # main 브랜치로의 PR이 생성되거나 업데이트될 때 실행
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      # 1. 저장소 코드 체크아웃
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      # 2. Node.js 환경 설정
      - name: Node.js 환경 설정
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      # 3. 의존성 설치 (npm ci는 package-lock.json을 기반으로 정확한 버전 설치)
      - name: 의존성 설치
        run: npm ci
      
      # 4. 코드 린트 검사 (코드 스타일 및 잠재적 오류 확인)
      - name: 린트 검사 실행
        run: npm run lint
      
      # 5. 테스트 실행
      - name: 테스트 실행
        run: npm test
        # 테스트 스크립트가 없을 경우에도 워크플로우가 중단되지 않도록 설정
        continue-on-error: true

      # 5-1. 브랜치별 API Base URL 설정 (dev → dev.q-feed.com, main → q-feed.com)
      - name: API Base URL 설정
        id: api-url
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "url=https://q-feed.com" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            echo "url=https://dev.q-feed.com" >> $GITHUB_OUTPUT
          else
            echo "url=https://q-feed.com" >> $GITHUB_OUTPUT
          fi
      
      # 6. 프로젝트 빌드 (dist 디렉토리 생성)
      - name: 프로젝트 빌드
        env:
          VITE_API_BASE_URL: ${{ steps.api-url.outputs.url }}
          VITE_SHOW_REAL_INTERVIEW: false
          VITE_SHOW_PORTFOLIO_INTERVIEW: false
          VITE_SHOW_NOTIFICATIONS: false
        run: npm run build
      
      # 7. package.json에서 버전 정보 추출
      - name: 패키지 버전 추출
        id: package-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      # 8. 빌드된 dist 디렉토리를 tar.gz 형식으로 압축
      # 파일명 형식: fe-{version}.tar.gz (예: fe-v0.0.0.tar.gz)
      - name: 빌드 결과물 압축
        run: tar -czf fe-v${{ steps.package-version.outputs.version }}.tar.gz dist/
      
      # 9. 압축된 파일을 GitHub Artifacts에 업로드
      - name: 빌드 산출물 업로드
        uses: actions/upload-artifact@v4
        with:
          # artifact 이름에 버전 포함 (예: fe-build-v0.0.0)
          name: fe-v${{ steps.package-version.outputs.version }}
          # 업로드할 파일 경로
          path: fe-v${{ steps.package-version.outputs.version }}.tar.gz
          # 90일 동안 보관 후 자동 삭제
          retention-days: 90
          # 이미 tar.gz로 압축되어 있으므로 추가 압축 불필요
          compression-level: 0

      # 서버 업로드까지 완료 시 CI 통과 알림 (Discord)
      - name: Discord 알림 (CI 통과)
        if: success()
        continue-on-error: true
        run: |
          curl -sS -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "embeds": [{
                "title": "✅ FE CI 통과",
                "description": "빌드·테스트·아티팩트 업로드 및 **서버 파일 업로드**까지 완료되었습니다.",
                "color": 3066993,
                "fields": [
                  {"name": "브랜치", "value": "'"${{ github.ref_name }}"'", "inline": true},
                  {"name": "커밋", "value": "`'"${{ github.sha }}"'`", "inline": true},
                  {"name": "트리거", "value": "'"${{ github.event_name }}"'", "inline": true}
                ],
                "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
              }]
            }'
            
  deploy-prod:
    name: Deploy to Production (EC2)
    runs-on: ubuntu-latest
    needs: build-and-test

    # main 브랜치로 push된 경우에만 배포 실행
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4

      - name: 패키지 버전 추출
        id: package-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: 빌드 산출물 다운로드
        uses: actions/download-artifact@v4
        with:
          name: fe-v${{ steps.package-version.outputs.version }}

      # 서버로 산출물을 전송한 뒤, 서버 내부 deploy.sh로 교체/백업 처리
      - name: SSH 키 설정
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.QFEED_EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.QFEED_EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: 서버 연결 테스트
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -o ServerAliveInterval=10 \
            ${{ secrets.QFEED_EC2_USER }}@${{ secrets.QFEED_EC2_HOST }} \
            "echo 'Connection successful'"

      - name: 서버로 파일 업로드 (SCP)
        timeout-minutes: 5
        run: |
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=60 \
            -o ServerAliveInterval=10 \
            -o ServerAliveCountMax=3 \
            fe-v${{ steps.package-version.outputs.version }}.tar.gz \
            ${{ secrets.QFEED_EC2_USER }}@${{ secrets.QFEED_EC2_HOST }}:/tmp/

      - name: 서버에서 배포 실행 (deploy-fe.sh)
        timeout-minutes: 5
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.QFEED_EC2_HOST }}
          username: ${{ secrets.QFEED_EC2_USER }}
          key: ${{ secrets.QFEED_EC2_SSH_KEY }}
          timeout: 60s
          command_timeout: 5m
          
          script: |
            set -e
            sudo /srv/qfeed/deploy-fe.sh /tmp/fe-v${{ steps.package-version.outputs.version }}.tar.gz

  deploy-dev:
    name: Deploy to Dev (EC2)
    runs-on: ubuntu-latest
    needs: build-and-test

    # dev 브랜치로 push된 경우에만 배포 실행
    if: github.event_name == 'push' && github.ref == 'refs/heads/dev'

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4

      - name: 패키지 버전 추출
        id: package-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: 빌드 산출물 다운로드
        uses: actions/download-artifact@v4
        with:
          name: fe-v${{ steps.package-version.outputs.version }}

      # 서버로 산출물을 전송한 뒤, 서버 내부 deploy.sh로 교체/백업 처리
      - name: SSH 키 설정
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.QFEED_EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.QFEED_EC2_DEV_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: 서버 연결 테스트
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            -o ServerAliveInterval=10 \
            ${{ secrets.QFEED_EC2_USER }}@${{ secrets.QFEED_EC2_DEV_HOST }} \
            "echo 'Connection successful'"

      - name: 서버로 파일 업로드 (SCP)
        timeout-minutes: 5
        run: |
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=60 \
            -o ServerAliveInterval=10 \
            -o ServerAliveCountMax=3 \
            fe-v${{ steps.package-version.outputs.version }}.tar.gz \
            ${{ secrets.QFEED_EC2_USER }}@${{ secrets.QFEED_EC2_DEV_HOST }}:/tmp/

      - name: 서버에서 배포 실행 (deploy-fe.sh)
        timeout-minutes: 5
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.QFEED_EC2_DEV_HOST }}
          username: ${{ secrets.QFEED_EC2_USER }}
          key: ${{ secrets.QFEED_EC2_SSH_KEY }}
          timeout: 60s
          command_timeout: 5m
          script: |
            set -e
            sudo /srv/qfeed/deploy-fe.sh /tmp/fe-v${{ steps.package-version.outputs.version }}.tar.gz

  # CI 실패 시 어떤 과정에서 실패했는지 Discord 알림
  discord-notify-failure:
    name: Discord 알림 (실패 상세)
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy-prod, deploy-dev]
    if: always() && (needs.build-and-test.result == 'failure' || needs.deploy-prod.result == 'failure' || needs.deploy-dev.result == 'failure')
    steps:
      - name: 실패한 Job/Step 조회
        id: failed
        run: |
          RES=$(curl -sS -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs")
          FAILED_JOB=$(echo "$RES" | jq -r '.jobs[] | select(.conclusion == "failure") | .name' | head -1)
          FAILED_JOB_ID=$(echo "$RES" | jq -r '.jobs[] | select(.conclusion == "failure") | .id' | head -1)
          if [ -n "$FAILED_JOB_ID" ]; then
            STEPS_RES=$(curl -sS -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/jobs/$FAILED_JOB_ID")
            FAILED_STEP=$(echo "$STEPS_RES" | jq -r '.steps[] | select(.conclusion == "failure") | .name' | head -1)
          else
            FAILED_STEP="(확인 불가)"
          fi
          [ -z "$FAILED_JOB" ] && FAILED_JOB="(알 수 없음)"
          [ -z "$FAILED_STEP" ] && FAILED_STEP="(알 수 없음)"

          # 어떤 job(단계)에서 실패했는지에 따라 Discord 메시지 내용을 다르게 구성
          STAGE="unknown"
          TITLE="❌ FE 워크플로우 실패"
          TARGET="(알 수 없음)"

          if [ "${{ needs.build-and-test.result }}" = "failure" ]; then
            STAGE="build-and-test"
            TITLE="❌ FE CI 실패 (빌드/테스트)"
            TARGET="CI"
          elif [ "${{ needs.deploy-prod.result }}" = "failure" ]; then
            STAGE="deploy-prod"
            TITLE="❌ FE 배포 실패 (Production)"
            TARGET="PROD (EC2_HOST 시크릿 사용)"
          elif [ "${{ needs.deploy-dev.result }}" = "failure" ]; then
            STAGE="deploy-dev"
            TITLE="❌ FE 배포 실패 (Dev)"
            TARGET="DEV (EC2_DEV_HOST 시크릿 사용)"
          fi

          # 실패 Step 기반으로 바로 실행 가능한 점검 가이드 생성
          GUIDE="Actions 로그에서 에러 스택/메시지를 확인하세요."
          case "$FAILED_STEP" in
            "의존성 설치"*)
              GUIDE=$'의존성 설치 실패\n- package-lock.json 충돌/손상 여부 확인\n- 로컬에서: npm ci\n- Node 버전(20)과 패키지 호환성 확인'
              ;;
            "린트 검사 실행"*)
              GUIDE=$'린트 실패\n- 로컬에서: npm run lint\n- 실패 파일/규칙 확인 후 수정'
              ;;
            "테스트 실행"*)
              GUIDE=$'테스트 실패\n- 로컬에서: npm test\n- 테스트가 flaky면 원인(네트워크/타임아웃/환경 변수) 확인'
              ;;
            "프로젝트 빌드"*)
              GUIDE=$'빌드 실패\n- 로컬에서: npm run build\n- VITE_* 환경 변수 주입/값 확인\n- (dev/main 분기) VITE_API_BASE_URL 값이 기대와 같은지 확인'
              ;;
            "SSH 키 설정"*)
              GUIDE=$'SSH 키 설정 실패\n- secrets.QFEED_EC2_SSH_KEY 값이 PEM 형식인지 확인\n- 줄바꿈 포함 여부/권한(chmod 600) 확인'
              ;;
            "서버 연결 테스트"*)
              GUIDE=$'서버 연결 실패\n- 대상 서버에서 22번 포트/보안그룹 허용 확인\n- host/user 시크릿 값 확인 (값 자체는 노출 금지)\n- 서버가 살아있는지(Ping/EC2 상태) 확인'
              ;;
            "서버로 파일 업로드 (SCP)"*)
              GUIDE=$'SCP 업로드 실패\n- /tmp 디스크 용량/권한 확인\n- 네트워크/보안그룹/SSH 연결 안정성 확인'
              ;;
            "서버에서 배포 실행 (deploy-fe.sh)"*)
              GUIDE=$'배포 스크립트 실행 실패\n- 서버에 /srv/qfeed/deploy-fe.sh 존재/실행권한 확인\n- sudo 권한 및 스크립트 내부 로그 확인\n- tar.gz 경로(/tmp/fe-vX.Y.Z.tar.gz) 확인'
              ;;
          esac

          echo "job=$FAILED_JOB" >> $GITHUB_OUTPUT
          echo "step=$FAILED_STEP" >> $GITHUB_OUTPUT
          echo "stage=$STAGE" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          # multiline 지원을 위해 heredoc 형태로 output 작성
          {
            echo "guide<<'EOF'"
            echo "$GUIDE"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Discord 알림 (실패 상세)
        continue-on-error: true
        run: |
          PAYLOAD=$(jq -n \
            --arg job "${{ steps.failed.outputs.job }}" \
            --arg step "${{ steps.failed.outputs.step }}" \
            --arg stage "${{ steps.failed.outputs.stage }}" \
            --arg title "${{ steps.failed.outputs.title }}" \
            --arg target "${{ steps.failed.outputs.target }}" \
            --arg guide "${{ steps.failed.outputs.guide }}" \
            --arg ref "${{ github.ref_name }}" \
            --arg sha "${{ github.sha }}" \
            --arg url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{
              embeds: [{
                title: $title,
                description: (
                  "**대상:** " + $target + "\n"
                  + "**실패한 Job:** " + $job + "\n"
                  + "**실패한 Step:** " + $step + "\n\n"
                  + "**점검 가이드**\n" + $guide + "\n\n"
                  + "_상세 로그는 Run 보기 링크에서 확인하세요._"
                ),
                color: 15158332,
                fields: [
                  {name: "브랜치", value: $ref, inline: true},
                  {name: "커밋", value: ("`" + $sha + "`"), inline: true},
                  {name: "Stage", value: $stage, inline: true},
                  {name: "워크플로우", value: ("[Run 보기](" + $url + ")"), inline: false}
                ],
                timestamp: $ts
              }]
            }')
          curl -sS -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"
